
#from pryr package
substitute_q <- function(x, env)
{
  call <- substitute(substitute(x, env), list(x = x))
  eval(call)
}

#' Create list of formulas for expected read numbers
#' 
#' @param ... list of named arguments; names represent condition labels,
#' the arguments values are unquoted expressions, which define formulas
#' for estimation of mean read number.
#'
#' @return list with keys corresponding to condition names and values as
#'   unevaluated call objects
#' @export
#'
#' @examples
#' \dontrun{
#' formulas <- MeanFormulas(total=mu, labelled=mu*d, unlabelled=mu*(1-d))
#' }
MeanFormulas <- function(...) {
  eval(substitute(alist(...)))
}

makeVector <- function(forms) {
  string <- paste("c(",
                  paste(mapply(
                    paste, names(forms), as.character(forms), sep = "="
                  ),
                  collapse = ","),
                  ")")
  parse(text = string)[[1]]
}

#' Generate a new formula for the mean read number
#' 
#' If the condition A can be contaminated with reads from the condition B,
#' its expected mean read number will be \eqn{(1-p)r_a + p r_b}, where
#' \eqn{p} is cross-contamination rate and \eqn{r_a,r_b} are
#' expected mean read numbers for conditions A and B, correspondingly.
#'
#' @param formulas list, generated by \code{\link{MeanFormulas}}
#' @param target_condition character; a condition, 
#'     for which a new formulas is to be generated
#' @param contaminant_condition character; a condition, which reads can contaminate
#'     fraction corresponding to \code{target_condition}
#' @param coef_name character; the name of the cross-contamination rate
#'
#' @return unevaluated call, as from \code{\link{quote}} function
#' 
#' @export
#' @examples
#' \dontrun{
#' forms <- MeanFormulas(A=r_a, B=r_b)
#' forms[["A"]] <- contaminate(forms, "A", "B", "p")
#' }
contaminate <- function(formulas,
                        target_condition,
                        contaminant_condition,
                        coef_name) {
  f1 <- deparse(formulas[[target_condition]])
  f2 <- deparse(formulas[[contaminant_condition]])
  e <- paste("(1-", coef_name, ")*(", f1, ")+", coef_name, "*(", f2, ")")
  parse(text = e)[[1]]
}

#' Evaluate formulas according to parameters, given in 
#' the condition \code{data.frame}
#'
#' @param formulas list, generated by \code{\link{MeanFormulas}}
#' @param conditions a data.frame; the first column corresponds to
#' to \code{names(formulas)}, conditions given by the formulas.
#' Other columns, if exist, contain parameter values, which are sample specific.
#' The order of rows corresponds to the order of samples.
#'
#'
#' @return list; formulas with substituted parameters according to the values
#' in the \code{conditions} data.frame
#'
constructFormulas <- function(formulas, conditions) {
  result <- lapply(rownames(conditions), function(x) {
    sampleCondition <- conditions[x, 1L]
    substitute_q(formulas[[sampleCondition]],
                 conditions[x, -1, drop = FALSE])
  })
  names(result) <- rownames(conditions)
  result
}

getNormFactors <- function(pulseData, par) {
  norm_factors <- pulseData$norm_factors
  if (!is.null(par$fraction_factors)) {
    norm_factors <-
      norm_factors * c(1, par$fraction_factors)[as.integer(pulseData$fraction)]
  }
  norm_factors
}

#' Create a likelihood function for gene-specific parameters
#' 
#' The values of shared parameters, \code{size} from \code{\link{dnbinom}} and
#' normalisation factors are taken from \code{par}. 
#'
#' @param pulseData PulseData object
#' @param par list; must have fields \code{shared_params}, \code{size},
#'  \code{individual_params}, \code{fraction_factors}.
#'
#' @return a function(params, counts), which returns a  log likelihood
#' for a given vector of individual parameters, which are ordered as in 
#' \code{par$individual_params}. 
#' @importFrom stats dnbinom
#'
ll_gene <- function(pulseData, par) {
  mean_indexes <- sapply(pulseData$conditions, match, names(pulseData$formulas))
  formulas <- pulseData$formulas
  if (!is.null(par$shared_params))
    formulas <- lapply(formulas, substitute_q, par$shared_params)
  means_vector <-  makeVector(formulas)
  param_names <- names(par$individual_params)
  norm_factors <- getNormFactors(pulseData, par)
  function(params, counts) {
    mus <- eval(means_vector, as.list(params))
    if(any(mus<=0)) return(Inf)
    lambdas <-  mus[mean_indexes]
    - sum(dnbinom(
      x    = counts,
      mu   = lambdas * norm_factors,
      log  = TRUE,
      size = par$size
    ))
  }
}

#' Create a likelihood function for shared parameters
#' 
#' The values of gene-specific parameters, \code{size} from
#'  \code{\link{dnbinom}} and
#' normalisation factors are taken from \code{par}. 
#' @inheritParams ll_gene
#'
#' @return a function(params, counts), which returns a  log likelihood
#' for a given vector of shared parameters, which are ordered as in 
#' \code{par$shared_params}.
#' @importFrom stats dnbinom
#'
ll_shared_params <- function(pulseData, par) {
  shared_param_names <- names(par$shared_params)
  norm_factors <- getNormFactors(pulseData, par)
  function(shared_params) {
    names(shared_params) <- shared_param_names
    means <- getMeans(shared_params,
                      pulseData$formulas,
                      par$individual_params)
    mean_indexes <-
      sapply(pulseData$conditions, match, names(pulseData$formulas))
    lambdas <- t(t(means[, mean_indexes]) * norm_factors)
    - sum(dnbinom(
      x    = pulseData$count_data,
      mu   = lambdas,
      log  = TRUE,
      size = par$size
    ))
  }
}

ll_norm_factors <- function(pulseData, par) {
  means <- getMeans(par$shared_params,
                    pulseData$formulas,
                    par$individual_params)
  mean_indexes <-
    sapply(pulseData$conditions, match, names(pulseData$formulas))
  lambdas <- means[, mean_indexes]
  norm_indexes <- as.integer(pulseData$fraction)
  function(fraction_factors) {
    fraction_factors <-
      c(1, fraction_factors)[norm_indexes] * pulseData$norm_factors
    norm_lambdas <- t(t(lambdas) * fraction_factors)
    if(any(norm_lambdas<=0)) return(Inf)
    - sum(dnbinom(
      x    = pulseData$count_data,
      mu   = norm_lambdas,
      log  = TRUE,
      size = par$size
    ))
  }
}

getMeans <- function(shared_params, formulas, individual_params) {
  shared_params <- as.list(shared_params)
  means <- lapply(formulas, function(x) {
    eval(substitute_q(x, shared_params),
         envir = as.list(individual_params))
  })
  means <- do.call(cbind, means) 
  means
}

ll_dispersion <- function(pulseData, par) {
  norm_factors <- getNormFactors(pulseData, par)
  means <- getMeans(par$shared_params,
    pulseData$formulas,
    par$individual_params)
  mean_indexes <- sapply(pulseData$conditions, match, names(pulseData$formulas))
  lambdas <- t(t(means[, mean_indexes]) * norm_factors)
  function(size) {
    -sum(dnbinom(
        x    = pulseData$count_data,
        mu   = lambdas,
        log  = TRUE,
        size = size
      )
    )
  }
}

predict.expression <- function(fit, pulseData) {
  means <- getMeans(fit$shared_params,
                    fit$formulas,
                    fit$individual_params)
  llog <- NULL
  if (!missing(pulseData)) {
    mean_indexes <-
      sapply(pulseData$conditions, match, names(pulseData$formulas))
    means <- means[, mean_indexes] * pulseData$norm_factors
    colnames(means) <- colnames(pulseData$count_data)
    llog <- dnbinom(
      x = pulseData$count_data,
      mu = means,
      log = TRUE,
      size = fit$size
    )
  }
  list(predictions = means, llog = llog)
}

log2screen <- function(options, ...) {
  if (options$verbose == "verbose")
    cat(...)
}


evaluateLikelihood <- function(pulseData, par ) {
  objective <- ll_dispersion(pulseData, par)
  objective(par$size)
}
