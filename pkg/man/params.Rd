% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parameters.R
\name{normaliseNormFactorBoundaries}
\alias{normaliseNormFactorBoundaries}
\alias{normaliseBoundaries}
\alias{addDefault}
\alias{validateOptions}
\alias{checkThresholds}
\alias{setBoundaries}
\alias{setTolerance}
\alias{setFittingOptions}
\alias{initParameters}
\alias{stopIfNotInRanges}
\alias{guessMeans}
\title{Shape boundaries for the normalisation factors

Create lower and upper boundaries with the same structure as
the list of normalisation coefficients \code{interSamplCoeffs} in
the \code{\link{PulseData}} object.}
\usage{
normaliseNormFactorBoundaries(options, pd)

normaliseBoundaries(options, par, pd)

addDefault(options)

validateOptions(options)

checkThresholds(options)

setBoundaries(boundaries, normFactors = c(0.01, 10),
  options = .defaultParams)

setTolerance(params = 0.01, shared = 0.01, normFactors = 0.01,
  options = .defaultParams)

setFittingOptions(verbose = c("silent", "verbose"),
  options = .defaultParams)

initParameters(par, geneParams, pulseData, options)

stopIfNotInRanges(args, options)

guessMeans(pulseData, totalLabel = "total", fun = c("mean", "geomean",
  "median"))
}
\arguments{
\item{options}{the options list}

\item{pd}{the \code{\link{PulseData}} object}

\item{par}{the parameters list}

\item{boundaries}{a named list of lower and  upper boundaries
for the parameters which are used in the formulas.}

\item{normFactors}{either a vector of length 2 or
a list of two lists (lower, upper boundaries).}

\item{params}{a threshold for gene-specific parameter boundaries}

\item{shared}{a threshold for shared parameters boundaries}

\item{verbose}{if "verbose" relative changes of parameters
between two fitting iterations are printed}

\item{geneParams}{a vector of names of the gene-specific parameters.
For this parameters, the output length is equal the number of genes, i.e.
an individual parameter value is generated for every gene.}

\item{pulseData}{a \code{\link{PulseData}} object}

\item{args}{a list of parametets}

\item{totalLabel}{a character, the name of the factor level in the
condition matrix, which correspond to the total fraction ("total" by default).}

\item{fun}{a function used to estimate the expression level.
Possible variants are mean, median and adjusted geometric mean (i.e.
$exp(mean(log(x + .5)))$.}

\item{options}{the options list}

\item{pd}{the \code{\link{PulseData}} object}

\item{options}{an options list}

\item{options}{an options list}

\item{options}{an options list}

\item{options}{an options object to use as a basis for a new parameter set}

\item{normFactors}{a threshold for the fraction factors}

\item{options}{an options object to use as a basis for a new parameter set}

\item{options}{an option object}

\item{par}{a list with parameter values}

\item{options}{an options object}

\item{options}{an options object}

\item{pulseData}{the \code{\link{PulseData}} object}
}
\value{
an updated options list

an updated options list

an updated options list with the default records added for
unspecified fields

an options object with the new parameter values

an options object with the new parameter values

an option object with modified specified parameters.

a list to provide to the function \code{\link{fitModel}}.

a vector of expression level estimations for every gene
}
\description{
The following cases for options${lb,ub}$normFactors are considered:
\itemize{
\item the structure is the same with \code{pd$interSampleCoeffs}
\item the length equals the number of unique conditions,
then the list is multiplied according to the condition data.frame
in order to generate a list with the same structure as
\code{pd$interSampleCoeffs}
\item only a single scalar value is provided.
}

If a single scalar value is provided, its boundaries are
assumed to be the same for all genes/isoforms, hence
a vector of gene number size will be returned.

Add default options if unset.

Throws an error if incorrect values are supplied.

Throws an error in case wrong format or value are provided.

Set optimization boundaries for the model parameters.

Set the stopping criteria in a form of the relative
changes during fitting iterations.

Specify fitting options

Initialize first guess for the parameters

Validate list of parameters according to allowed value ranges.

Estimate initial guess for the mean expression level
}
\details{
If no options object is provided, the default values are used.
The elements in the boundaries list are either
\itemize{
\item a list of two vectors
(the lower and upper boundaries for every gene/isoform respectively).
If a vector is of length 1, equal boundary values will be assumed for
all genes (e.g. for the lower boundary);
\item a vector of two scalars.
}

The normFactors elements (two, for the lower and the upper
boundaries) can be:
\itemize{
\item a list with the structure is the same with the \code{interSampleCoeffs} in
the \code{\link{PulseData}} object used in the analysis;
\item a list with the length equals the number of unique conditions;
the structure is the same as \code{formulaIndexes} object used for
the \code{\link{PulseData}} object creation;
\item a single scalar value.
}

If no options object is provided, the default options are used
as a base.
A threshold  represents the relative changes in parameter values
between two subsequent fitting iterations.

Use this function to estimate mean read numbers
on the basis of the total fraction.
}
\examples{
opts <- addDefault(list())

# the simple way:
setBoundaries(list(a = c(1,2), b = c(10, 20)), 
              normFactors = c(.1,10))
              
# the hard way:
# this are the formula indexes (see PulseData function documentation)
formulaIndexes <- list(
  total_fraction = 'total',
  pull_down      = c('labelled', 'unlabelled'),
  flow_through   = c('unlabelled', 'labelled')
)
# the lower and upper boundaries must have the same structure:
lbNormFactors <- list(
  total_fraction = 1,
  pull_down      = c(.1,.010),
  flow_through   = c(.1,.010))
ubNormFactors <- list(
  total_fraction = 1,
  pull_down      = c(10, 2),
  flow_through   = c(10, 2))
# we need to provide them as a list  
opts <- setBoundaries(
  list(mu = c(1, 1e6), d = c(1, 2)),
  normFactors = list(lbNormFactors, ubNormFactors))
  
setTolerance(params = 1e-2)

}
\keyword{internal}
