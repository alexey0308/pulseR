#' Create list of formulas for expected read numbers
#' 
#' @param ... list of named arguments; names represent condition labels,
#' the arguments values are unquoted expressions, which define formulas
#' for estimation of mean read number.
#'
#' @return list with keys corresponding to condition names and values as
#'   unevaluated call objects
#' @export
#'
#' @examples
#' \dontrun{
#' formulas <- MeanFormulas(total=mu, labelled=mu*d, unlabelled=mu*(1-d))
#' }
MeanFormulas <- function(...) {
  eval(substitute(alist(...)))
}

#' Generate a new formula as a mixture of two
#' 
#' If the condition A can be contaminated with reads from the condition B,
#' its expected mean read number will be \eqn{(1-p)r_a + p r_b}, where
#' \eqn{p} is cross-contamination rate and \eqn{r_a,r_b} are
#' expected mean read numbers for conditions A and B, correspondingly.
#'
#' @param formulas list, generated by \code{\link{MeanFormulas}}
#' @param target_condition character; a condition, 
#'     for which a new formulas is to be generated
#' @param contaminant_condition character; a condition, which reads can contaminate
#'     fraction corresponding to \code{target_condition}
#' @param coef_name character; the name of the cross-contamination rate
#'
#' @return unevaluated call, as from \code{\link{quote}} function
#' 
#' @export
#' @examples
#' \dontrun{
#' forms <- MeanFormulas(A=r_a, B=r_b)
#' forms[["A"]] <- contaminate(forms, "A", "B", "p")
#' }
contaminate <- function(formulas,
                        target_condition,
                        contaminant_condition,
                        coef_name) {
  f1 <- deparse(formulas[[target_condition]])
  f2 <- deparse(formulas[[contaminant_condition]])
  e <- paste("(1-", coef_name, ")*(", f1, ")+", coef_name, "*(", f2, ")")
  parse(text = e)[[1]]
}

#' Evaluate formulas according to parameters, given in 
#' the condition \code{data.frame}
#'
#' @param formulas list, generated by \code{\link{MeanFormulas}}
#' @param conditions a data.frame; the first column corresponds to
#' to \code{names(formulas)}, conditions given by the formulas.
#' Other columns, if exist, contain parameter values, which are sample specific.
#' The order of rows corresponds to the order of samples.
#'
#'
#' @return list; formulas with substituted parameters according to the values
#' in the \code{conditions} data.frame
#'
constructFormulas <- function(formulas, conditions) {
  result <- lapply(rownames(conditions), function(x) {
    sampleCondition <- conditions[x, 1L]
    substitute_q(formulas[[sampleCondition]],
                 conditions[x, -1, drop = FALSE])
  })
  names(result) <- rownames(conditions)
  result
}

toLanguage <- function(x) {
  if (!is.language(x))
    parse(text = x)[[1]]
  else
    x
}

#' Create a formula object for the initial RNA level.
#'
#' @param x a character or a language object (an expression, a call
#'        or a name)
#'
#' @return an expression for the initial RNA level
#' @export
#'
#' @examples
#' x <- amount("mu")
#' degrade_(x, d_rate, time)
#' # mu_0 * exp(-d_rate * time)
amount <- function(x){
 x <- toLanguage(x)
 x
}

#'  Create a formula object for the initial RNA level.
#'
#'  A non-standard evaluation version of the \code{\link{amount}} 
#'  function.
#'  
#' @param x an expression level
#'
#' @return an expression for the initial RNA level
#' @export
#'
amount_ <- function(x){
 substitute(x) 
}

#' Create a formula for RNA degradation
#' 
#' All the arguments must be characters or language objects 
#' (expression, call or name).
#' 
#' @param x  initial concentration.
#' @param d  a degradation rate.
#' @param t  a longitude of the modelled period.
#'
#' @return an expression for the calculation of the RNA level after
#' degradation during time \verb{t}.
#' @export
#'
#' @examples
#' x <- amount("mu_0")
#' mu <- amount_(mu_new)
#' d <- "degradation_rate"
#' t <- "t_labelling"
#' degrade(x, d, t)
#' # mu_0 * exp(-degradation_rate * t_labelling)
#' 
degrade <- function(x, d, t){
  args <- as.list(match.call()[-1])
  args <- lapply(args, eval, env = parent.frame())
  args <- lapply(args, toLanguage)
  args$x <- quote(x)
  do.call(degrade_, args) 
}

#' Create a formula for RNA degradation
#' 
#' Implements a non-standard evaluation version.
#'
#' @inheritParams degrade
#'
#' @return an expression for the calculation of the RNA level after
#' degradation during time \verb{t}.
#' @export
#'
#' @examples
#' x <- amount("a")
#' degrade_(x,b,c)
#' # a * exp(-b * c)
#' 
degrade_ <- function(x, d, t) {
  args <- as.list(match.call()[-1])
  args$x <- toLanguage(x)
  bquote(.(x) * exp(-.(d) * .(t)), args)
}

#' Creates a formula which describe evolution of RNA concentration
#'
#' All the arguments must be characters or language objects 
#' (expression, call or name).
#' 
#' @param x  initial concentration.
#' @param mu new steady-state level.
#' @param d  a degradation rate.
#' @param t  a longitude of the modelled period.
#'
#'
#' @return an expression for the calculation of the RNA level after time
#' \verb{t}.
#' @export
#'
#' @examples
#' x <- amount_(mu_0)
#' mu <- amount("mu_new")
#' d <- "degradation_rate"
#' t <- "t_labelling"
#' grow(x, mu, d, t)
#' # mu_new - (mu_new - mu_0) * exp(-degradation_rate * t_labelling)
grow <- function(x, mu, d, t) {
  args <- as.list(match.call()[-1])
  args <- lapply(args, eval, env = parent.frame())
  args <- lapply(args, toLanguage)
  args$x <- quote(x)
  do.call(grow_, args) 
}

#' Creates a formula which describe evolution of RNA concentration
#' if the initial amount is 0.
#'
#' All the arguments must be characters or language objects 
#' (expression, call or name).
#'
#' @inheritParams grow 
#' @return an expression to calculate the RNA level.
#' @export
#'
#' @examples
#' growFrom0("b","c","d")
#' # b - b * exp(-c * d)
#' 
growFrom0 <- function(mu, d, t) {
  args <- as.list(match.call()[-1])
  args <- lapply(args, eval, env = parent.frame())
  args <- lapply(args, toLanguage)
  do.call(grow_, args) 
}

#' Creates a formula which describe evolution of RNA concentration
#' 
#' This implement the non-standard evaluation version of the 
#' \code{\link{grow}} function.
#' @inheritParams grow
#' @return an expression for the calculation of the RNA level.
#' @export
#'
#' @examples
#' x <- amount("a")
#' grow_(x,b,c,d)
#' # b - (b - a) * exp(-c * d)
#' 
grow_ <- function(x, mu, d, t) {
  args <- as.list(match.call()[-1])
  if (!missing(x)) {
    args$x <- toLanguage(x)
    bquote(.(mu) - (.(mu) - .(x)) * exp(-.(d) * .(t)), args)
  } else {
    bquote(.(mu) * (1 - exp(-.(d) * .(t))), args)
  }
}

