---
title: "The workflow"
author: "Uvarovskii Alexey"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r include=FALSE}
library(pulseR)
```

## Overview

The workflow consists of defining the data object, setting fitting options
and fitting itself:

```{r eval=FALSE}
library(pulseR)
...
# define the data
pd <- PulseData(...)
# set options 
opts <- setTolerance(...)
opts <- setBoundaries(..., opts)
# define first parameter guess
initPars <- initParameters(...)
# fit the model
fit <- fitModel(pd, initPars, opts)
```

## PulseData object

In the `pulseR` package, we keep all inial data in the `PulseData` structure
(S3 class). When the information about read counts, conditions and the model is
defined, one can create the object with a line as 

```{r eval=FALSE}
library(pulseR)
pd <- PulseData(counts, conditions, formulas, formulaIndexes, groups)
```

#### Counts

The read counts must be delivered as an integer matrix.
The rownames may describe the gene names and the column order corresponds to the
sample order in the condition matrix (see below) 
```{r echo=FALSE}
pulseRSpikeinsData$counts[1:20, 1:4]
```

#### Condition matrix

The information about samples must be described in the condition matrix.
It is obligatory that the row order corresponds to the column order in the
count matrix. Time or other sample-specific variable are defined here.

```{r echo=FALSE}
pulseRSpikeinsData$conditions
```

#### Formulas

The experiment design defines how different fractions evolve with the time.

```{r echo=TRUE}
formulas <- MeanFormulas(
  total      =  mu,
  labelled   =  mu * exp(-d * time),
  unlabelled =  mu *exp(-d * time))
```

One may use the helper functions, e.g.`amount`, `degrade`, `grow`:

```{r collapse=TRUE}
degrade("mu","d","time")
```

#### Fraction content

In pulseR, it is possible to model contamination of the fractions.
This definition is passed as `formulaIndexes` argument to the `PulseData`
function.
Here we define the the pull-down fraction consists of the labelled and
unlabelled molecules, and the total fraction is degenerates to a simple 
formulas, which we defined in addition in the `formulas` list:

```{r result="none"}
formulaIndexes <- list(total_fraction = "total",
                       pull_down = c("labelled", "unlabelled"))
```


#### Normalisation

##### Using spike-ins

Samples can be normalised using spike-ins. In this case,
we assume that labelled and unlabelled spike-in molecules 
were added in the same proportion to the total RNA amount to all the samples.

```{r collapse=TRUE}
pulseRSpikeinsData$spikeins
```

```{r eval=FALSE}
pd <- PulseData(counts, conditions, formulas, formulaIndexes, 
                spikeins = spikeins)
```

##### Without spike-ins

Alternatively, the relations between samples can be inferred during the 
fitting procedure.
We implement it in two steps:

- Samples from the same group are normalised according to the 
  sequencing depth using the same technique as in the DESeq package.
- Normalisation factors, which define the relations between the groups  and 
  fractions are fitted together with other parameters.

The way of sample grouping is defined in the `group` argument.
We assume that efficiency of the pull-down procedure is different 
between different time points (`time` column in the condition matrix):

```{r eval=FALSE}
pd <- PulseData(counts, conditions, formulas, formulaIndexes, 
                groups = ~ fraction + time)
```

## Model fitting

The model can be fit by the command
```{r eval=FALSE}
fit <- fitModel(pulseData = pd, par = initPars, options = opts)
```

The function will iteratively fit the parameters from the formulas, 
overdispersion parameter for the negative binomial distribution and,
if defined, the normalisation factors.

#### Initial values

The fitting procedure needs some initial guess for the parameter values.
The result of the fitting may depend on the model parametrisation and
the initial guess.

```{r eval=FALSE}
initPars <- initParameters(list(), c("mu", "d"), pulseData = pd, options = opts)


```

#### Fitting options

```{r eval=FALSE}
opts <- setBoundaries(list(
  mu = c(.1, 1e6),
  d = c(.01, 2)
))
opts <- setTolerance(params = 1e-3, normFactors = 1e-2, options = opts)
```

