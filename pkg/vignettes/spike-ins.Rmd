---
title: "PulseR with spike-ins"
author: "Uvarovskii Alexey"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r}
library(pulseR)
attach(pulseRSpikeinsData)

```


## Prepare a data set and conditions

### The experiment description

Let us have a labelling experiment with several time points

```{r}
formulas <- MeanFormulas(
  A = a,
  B =  a * b ^ time,
  C = alpha * a * (1 - b ^ time))

formulaIndexes <- list(
  A_samp = 'A',
  B_samp = c('B', 'C'),
  C_samp = c('B', 'C'))


```

Let $alpha$ be some parameter shared between genes and $a$, $b$ are the
gene specific parameters.



Here is the condistion matrix for our data set:

```{r}
conditions
```

## Spikeins in data
The count matrix consists of the read counts for the features of interest
as well as counts for the spike-ins, which are specified by row names.
```{r}
counts[,1:4]
```

Since usually it is interesting to consider cross-contamination between 
labelled and unlabelled fractions, we need to specify spike-ins sets
for these fractions. For example, the samples from the group "B_samp"
are contaminated with the "C" fraction. Hence, we need to provide to lists
of spike-ins for the "B_samp" samples: for the "B" fraction and for the "C"
fraction.
```{r}
spikeins$spikeLists$B_samp
```

It is very important to specify the reference group of samples,
which will be used for estimation of sequencing depth correction.

```{r}
spikeins$refGroup
```



## Create `PulseData` object

```{r}
pd <- PulseData(
  counts = counts,
  conditions = conditions,
  formulas = formulas,
  formulaIndexes = formulaIndexes,
  spikeins = spikeins
)
```


### Fitting options
Now we set options for fitting. It is important to provide boundaries for the
optimal parameter search:

```{r}
opts <- setBoundaries(list(
  a = c(.1, 1e6),
  b = c(.01, .99),
  alpha = c(.1,10)
))
```

For other possible parameters please see "set" functions in the package
documentation (`setBoundaries, setTolerance, setFittingOptions`).  

### Initial parameter guess
Optimisation procedure may depend on the initial parameter values.
A function `initParams` provides an intyerface to simplify this step.
There are two options for how to set the parameters:

- to sample random numbers within the given boundaries 
- manual values by the user

```{r}
initPars <- initParameters(par, c("a", "b"), pulseData = pd, options = opts)
```


## Fitting

You can specify other options as the number of cores or error 
tolerance thresholds for parameter fitting. The fitting procedure will stop,
once the difference in parameters values between two subsequent iteration is 
less than specified in `options$tolerance`.

The function `fitModel` accept the PulseData object, initial guess for the 
parameters values and fitting options.

```{r cache=TRUE}

opts <- setTolerance(params = 1e-3,
                     normFactors = 1e-2,
                     options = opts)
result <- fitModel(pd, initPars, opts)
```

```{r}
pr <- predictExpression(result, pd)

plot(
  x = as.vector(pr$predictions),
  y = as.vector(pd$counts),
  pch = 16,
  cex = .3,
  log = 'xy',
  xlab = "fitted",
  ylab = "experiment"
)
```



